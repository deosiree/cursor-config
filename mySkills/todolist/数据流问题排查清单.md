# 数据流问题排查清单 Skill

## 技能概述

这是一个用于排查和修复数据流问题的结构化框架，特别适用于状态变化、异步操作、DOM 更新等场景中的时序控制问题。

**核心原则**：
- 追踪数据流：从状态变化的起点到最终效果
- 时序控制：确保异步操作按正确顺序执行
- 职责分离：明确每个方法的职责边界
- 测试验证：确保测试用例符合实际业务逻辑

## 触发方式

当遇到以下情况时，可以使用此 skill：

1. **状态变化时序问题**：
   - 新状态已设置，但旧状态还未关闭
   - 状态变化后立即执行操作，但 DOM 还未更新
   - 视觉上出现闪烁或不流畅

2. **异步操作时序问题**：
   - 接口响应后立即执行操作，但 DOM 还未更新
   - 测试用例期望立即关闭，但实际代码在 `$nextTick` 中关闭
   - loading 状态提前关闭

3. **方法职责混淆问题**：
   - 期望某个方法执行操作，但实际职责不同
   - 测试用例调用错误的方法
   - 方法职责划分不清晰

## 排查流程

### Phase 1: 问题识别（Problem Identification）

**目标**：识别数据流问题的类型和影响范围

**检查清单**：

- [ ] **问题类型识别**
  - 状态变化时序问题（新状态已设置，但旧状态还未关闭）
  - 异步操作时序问题（接口响应后立即执行操作，但 DOM 还未更新）
  - 方法职责混淆问题（期望某个方法执行操作，但实际职责不同）
  - Loading 状态管理问题（loading 状态提前关闭）

- [ ] **影响范围评估**
  - 哪些功能受到影响？
  - 哪些测试用例失败？
  - 用户体验是否受到影响？

- [ ] **触发条件确认**
  - 什么操作触发了问题？
  - 是否只在特定场景下出现？
  - 是否与异步操作相关？

### Phase 2: 数据流追踪（Data Flow Tracing）

**目标**：追踪数据从起点到终点的完整流程

**分析方法**：

1. **状态变化路径追踪**
   - 从状态变化的起点（接口响应、用户操作）开始追踪
   - 检查每个状态变化是否触发了正确的副作用
   - 确认副作用执行的时序是否正确

2. **异步操作时序验证**
   - 列出所有异步操作（接口调用、DOM 更新）
   - 检查异步操作的执行顺序
   - 确认是否使用了 `$nextTick`、`await` 等待完成

3. **方法调用链分析**
   - 追踪方法调用的完整链路
   - 检查每个方法的职责是否清晰
   - 确认方法是否执行了超出职责范围的操作

**追踪模板**：

```
状态变化起点（接口响应/用户操作）
  ↓
设置新状态（visible = true）
  ↓
DOM 更新（异步）
  ↓
$nextTick 回调
  ↓
关闭旧状态（visible = false）
  ↓
关闭 loading 状态
```

### Phase 3: 根因定位（Root Cause Analysis）

**目标**：找到问题的根本原因

**分析维度**：

| 维度 | 检查项 | 说明 |
|------|--------|------|
| **时序控制** | watch 中是否执行副作用 | watch 应该只用于响应状态变化，不应该直接执行关闭操作 |
| | 是否使用 $nextTick | 在设置新状态后，应该使用 `$nextTick` 等待 DOM 更新完成 |
| | 异步操作是否按顺序执行 | 接口响应 → 设置新状态 → $nextTick → 关闭旧状态 |
| **状态管理** | loading 状态管理 | 接口调用期间保持 loading，在新模态框渲染完成后关闭 |
| | 状态关闭时机 | 是否在新模态框渲染完成后才关闭旧模态框 |
| **方法职责** | 方法职责是否清晰 | 每个方法应该只负责自己的职责范围 |
| | 测试用例调用是否正确 | 测试用例应该调用正确的方法 |

**常见根因**：

1. **使用 watch 立即执行副作用**
   - 问题：在 watch 中直接执行关闭操作，但 DOM 还未更新
   - 解决：将副作用操作移到业务逻辑方法中，使用 `$nextTick` 控制时序

2. **忽略异步操作的时序特性**
   - 问题：接口响应后立即关闭旧状态，但新状态还未渲染
   - 解决：使用 `$nextTick` 等待 DOM 更新完成后再执行关闭操作

3. **测试用例不符合实际业务逻辑**
   - 问题：测试用例直接设置状态，而不是通过业务逻辑方法触发
   - 解决：测试用例应该模拟实际的业务场景（接口调用、DOM 更新）

### Phase 4: 修复方案生成（Solution Generation）

**目标**：生成结构化的修复方案

**修复原则**：

1. **响应式关闭模式**
   ```
   接口响应 → 设置新状态 → $nextTick → 关闭旧状态
   ```

2. **Loading 状态管理**
   ```
   接口调用期间保持 loading → 新模态框渲染完成 → $nextTick → 关闭 loading
   ```

3. **方法职责分离**
   ```
   handleCloseInternal: 只关闭主模态框
   handleClose: 关闭所有模态框（包括校验和更新模态框）
   ```

**修复步骤**：

1. **移除 watch 中的副作用**
   - 从 watch 中移除关闭逻辑
   - 保留必要的响应逻辑（如 `setModalAriaHidden`）

2. **在业务逻辑方法中实现响应式关闭**
   - 接口响应后，先设置新状态
   - 使用 `$nextTick` 等待 DOM 更新完成
   - 在 `$nextTick` 回调中关闭旧状态

3. **管理 loading 状态**
   - 接口调用期间保持 loading
   - 在新模态框渲染完成后关闭 loading
   - 错误处理时确保 loading 被正确关闭

4. **修复测试用例**
   - 调整测试期望，等待异步操作完成
   - 使用实际业务逻辑方法触发状态变化
   - 区分方法职责，调用正确的方法

### Phase 5: 验证与预防（Verification & Prevention）

**目标**：验证修复效果并建立预防措施

**验证清单**：

- [ ] **功能验证**
  - 模态框切换是否流畅？
  - 是否还有视觉闪烁？
  - loading 状态是否正确管理？

- [ ] **测试验证**
  - 所有测试用例是否通过？
  - 测试用例是否覆盖实际业务场景？
  - 测试用例是否等待异步操作完成？

- [ ] **代码审查**
  - 是否遵循响应式关闭模式？
  - 方法职责是否清晰？
  - 是否避免了在 watch 中执行副作用？

**预防措施**：

1. **统一时序控制模式**
   - 所有模态框切换都遵循"接口响应 → 设置新状态 → $nextTick → 关闭旧状态"的模式
   - 避免在 watch 中执行副作用

2. **明确方法职责**
   - 在代码注释中明确说明方法的职责
   - 确保方法只负责自己的职责范围

3. **测试覆盖实际场景**
   - 测试应该模拟实际的业务场景（接口调用）
   - 考虑异步操作的时序特性（`$nextTick`、`await`）

## 使用示例

### 示例 1：模态框响应式关闭重构

**问题**：模态框切换时出现视觉闪烁，新模态框还未渲染完成，旧模态框就已经关闭。

**排查步骤**：

1. **问题识别**：状态变化时序问题，新状态已设置，但旧状态还未关闭
2. **数据流追踪**：
   - 接口响应 → 设置 `validationVisible = true` → watch 触发 → 立即关闭 `internalVisible`
   - 问题：新模态框还未渲染完成，旧模态框就已经关闭
3. **根因定位**：使用 watch 立即执行副作用，没有等待 DOM 更新完成
4. **修复方案**：
   - 移除 watch 中的关闭逻辑
   - 在 `handleValidation` 方法中，使用 `$nextTick` 等待新模态框渲染完成后再关闭旧模态框
5. **验证**：模态框切换流畅，无视觉闪烁

### 示例 2：测试用例修复

**问题**：测试用例失败，期望的行为与实际代码逻辑不一致。

**排查步骤**：

1. **问题识别**：测试用例不符合实际业务逻辑
2. **数据流追踪**：
   - 测试用例直接设置 `updateVisible = true`，期望 `validationVisible` 立即变为 `false`
   - 但实际代码中，关闭逻辑在 `handleBatchUpdate` 方法中，通过 `$nextTick` 执行
3. **根因定位**：测试用例基于旧的代码逻辑编写（watch 自动关闭），没有模拟实际的业务场景
4. **修复方案**：
   - 测试用例通过调用 `handleBatchUpdate` 来触发状态变化
   - 等待所有异步操作完成（`await nextTick()`）
5. **验证**：所有测试用例通过

## 相关文档

- 数据流问题易错清单：`.cursor/skills/todolist/数据流问题易错清单.md`
- Skill 文档：`.cursor/skills/data-flow-check.md`
- 组件实现示例：`src/components/Button/fileManage/backFill/modal_v1.5.vue`
- 测试示例：`tests/unit/components/BackFillModal_v1.5.test.js`

## 注意事项

- 数据流问题往往与异步操作相关，需要特别注意时序控制
- 测试用例应该模拟实际的业务场景，而不是直接设置状态
- 方法职责应该清晰，避免混淆
- 使用 `$nextTick` 确保 DOM 更新完成后再执行后续操作
