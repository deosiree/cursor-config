---
name: pdd-skill1_7-proto2planning
description: "分析代码更改，整理实现规则，划分原子任务。在原型设计阶段，将新增的业务逻辑与规则划分成足够小的原子任务，不落地代码，也不落地每个设计的细节。"
---

# Skill 1_7：从代码更改到原子任务划分

## 概述

- **所属阶段**：S2「原型评审 / 落地规划」
- **目标**：分析 git 暂存区的代码更改（非 .md 文件），识别新增的业务逻辑，整理实现规则，将业务逻辑与规则划分成足够小的原子任务，为后续生成原型设计文档做准备。
- **执行者**：Cursor（Code Analyst & Task Planner）
- **输入**：
  - 代码根目录路径（如 `F:\Documents\Repertory\Sieyuan\nebula\apex`）
  - Git 暂存区的所有代码更改（通过 `git diff --cached` 获取，排除 .md 文件）
- **输出**：
  - 结构化的原子任务列表
  - 每个任务包含：任务编号、任务名称、业务逻辑描述、实现规则要点
  - 不落地代码，也不落地每个设计的细节

---

## 定位与与其它 Skills 的关系

- **前置 Skill**：无（可直接使用）
- **后续 Skill**：
  - `pdd-skill1_8-proto2planning`：基于原子任务，整理清晰的新增业务逻辑与实现规则，补充完整任务内容
  - `pdd-skill1_9-proto2planning`：基于原子任务，生成完整的原型实现规划文档

> **重要心态**：本 Skill 专注于「分析」和「划分」，不涉及具体实现细节。每个原子任务应该足够小，便于后续逐步完善。

---

## 触发方式

- **推荐触发关键词**：
  - `@pdd-skill1_7-proto2planning`
  - `@pdd-analyze-code-changes`
  - `@分析代码更改并划分原子任务`

- **示例 1：分析当前暂存区的代码更改**

> `@pdd-skill1_7-proto2planning 分析 [apex] 中本次 git 暂存的所有代码（非 .md 的）更改，分析新增业务逻辑，整理实现规则，将当前新增的业务逻辑与规则划分成原子任务，要求每个子任务都足够小，不落地代码，也不落地每个设计的细节。`

- **示例 2：指定代码根目录**

> `@pdd-skill1_7-proto2planning 代码根目录：F:\Documents\Repertory\Sieyuan\nebula\apex，分析暂存区的代码更改，划分原子任务。`

---

## Skill 内部工作流

> **角色**：Code Analyst & Task Planner  
> **目标**：通过系统化分析，将代码更改转化为结构化的原子任务列表。

### 步骤 1：收集代码更改（Code Change Collection）

1. **获取 git 暂存区状态**：
   ```bash
   git status --short
   git diff --cached --name-only
   ```

2. **过滤非 .md 文件**：
   - 排除所有 `.md` 文件
   - 重点关注：`.vue`、`.ts`、`.js`、`.json`、`.scss` 等代码文件

3. **获取每个文件的更改内容**：
   ```bash
   git diff --cached <file-path>
   ```

4. **识别文件类型**：
   - 新增文件（`new file`）
   - 修改文件（`modified`）
   - 删除文件（`deleted`）

### 步骤 2：分析新增业务逻辑（Business Logic Analysis）

对每个更改的文件，识别以下内容：

1. **新增功能模块**：
   - 新组件（`.vue` 文件）
   - 新 API 接口（`.api.ts` 文件）
   - 新工具函数（`.ts` 文件）
   - 新 Mock 数据（`.mock.ts` 文件）

2. **业务逻辑要点**：
   - 核心功能描述（一句话）
   - 数据流向（输入 → 处理 → 输出）
   - 状态管理（响应式数据、Store）
   - 交互流程（用户操作 → 系统响应）

3. **实现规则识别**：
   - 数据验证规则
   - 错误处理规则
   - 权限控制规则
   - 版本管理规则（如适用）

### 步骤 3：整理实现规则（Implementation Rules Organization）

将识别出的实现规则按类别整理：

1. **数据规则**：
   - 数据结构定义
   - 数据转换规则
   - 数据验证规则

2. **业务规则**：
   - 业务逻辑判断条件
   - 状态转换规则
   - 异常处理规则

3. **交互规则**：
   - 用户操作触发条件
   - UI 反馈规则
   - 确认/取消流程

4. **技术规则**：
   - API 调用规则
   - 缓存策略
   - 性能优化规则

### 步骤 4：划分原子任务（Atomic Task Breakdown）

将业务逻辑与实现规则划分成原子任务，每个任务满足：

1. **任务粒度**：
   - 足够小（2-5 分钟可理解）
   - 单一职责（只做一件事）
   - 可独立描述（不依赖其他任务的细节）

2. **任务编号规则**：
   - 使用字母+数字组合（如 `A1`、`A2`、`B1`、`B2`）
   - 字母表示任务组（功能模块）
   - 数字表示组内序号

3. **任务内容结构**：
   ```markdown
   ### 任务 A1：<任务名称>
   
   **业务逻辑**：
   - <简要描述>
   
   **实现规则要点**：
   - <规则1>
   - <规则2>
   ```

4. **任务分组原则**：
   - 按功能模块分组（如：版本管理、菜单管理、按钮权限）
   - 按数据流向分组（如：数据获取、数据处理、数据展示）
   - 按交互流程分组（如：新增、编辑、删除、查询）

### 步骤 5：输出原子任务列表（Output Atomic Tasks）

以结构化的 Markdown 格式输出：

```markdown
# 原子任务列表

## 任务组 A：<功能模块1>

### 任务 A1：<任务名称>
**业务逻辑**：<描述>
**实现规则要点**：
- <规则1>
- <规则2>

### 任务 A2：<任务名称>
...

## 任务组 B：<功能模块2>
...
```

---

## 输出格式约定

1. **文档结构**：
   - 一级标题：`# 原子任务列表`
   - 二级标题：`## 任务组 X：<功能模块名>`
   - 三级标题：`### 任务 X1：<任务名称>`

2. **任务描述要求**：
   - **业务逻辑**：用一句话描述该任务要解决什么问题
   - **实现规则要点**：列出 2-5 个关键规则点，不展开细节

3. **不包含内容**：
   - 不包含具体代码实现
   - 不包含详细设计细节
   - 不包含测试用例
   - 不包含文件路径（除非是任务的核心标识）

---

## 最佳实践与使用建议

- **何时使用本 Skill**：
  - 在代码更改后，需要系统化分析新增功能时
  - 在生成原型设计文档之前，需要明确任务范围时
  - 在代码评审前，需要梳理实现逻辑时

- **如何迭代**：
  - 可以多次触发本 Skill，每次基于最新的 git 暂存区状态
  - 可以针对特定文件或目录进行分析

- **如何与其它 Skill 协作**：
  - 完成后，使用 `pdd-skill1_8-proto2planning` 补充任务细节
  - 再使用 `pdd-skill1_9-proto2planning` 生成完整的原型实现规划

---

## 示例输出

```markdown
# 原子任务列表

## 任务组 A：版本映射表管理

### 任务 A1：定义版本映射表数据结构
**业务逻辑**：定义版本映射表的数据结构，包括菜单ID、版本号、组件路径等字段。
**实现规则要点**：
- 版本号格式：`版本X.Y`（如 `版本1.0`）
- 菜单ID与版本号组合唯一
- 支持菜单和按钮权限两种类型

### 任务 A2：实现版本映射表查询接口
**业务逻辑**：提供根据菜单ID和版本号查询版本映射的接口。
**实现规则要点**：
- 支持按菜单ID查询所有版本
- 支持按菜单ID+版本号查询单个映射
- 返回数据需标准化版本号格式

## 任务组 B：菜单版本切换

### 任务 B1：定义全局版本切换流程
**业务逻辑**：实现租户级别的菜单版本全局切换功能。
**实现规则要点**：
- 切换时更新租户配置中的当前版本号
- 同步更新菜单表中的版本信息
- 触发前端菜单列表刷新
```
