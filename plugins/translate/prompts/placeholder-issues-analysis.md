# 占位符问题分析与解决方案

生成时间: 2026-01-28

## 问题1: 句首占位符丢失

### 问题描述
当占位符token（如 `⟦__PH_CURLY_0__⟧`）位于句首时，翻译结果中该占位符会丢失。

**示例:**
- 原文: `⟦__PH_CURLY_0__⟧ 资源预警，资源增长速度：⟦__PH_CURLY_1__⟧⟦__PH_CURLY_2__⟧/s，预计还剩 ⟦__PH_CURLY_3__⟧⟦__PH_CURLY_4__⟧ 资源枯竭，资源预警值：⟦__PH_CURLY_5__⟧⟦__PH_CURLY_6__⟧，预警计算时间【⟦__PH_CURLY_7__⟧-⟦__PH_CURLY_8__⟧】`
- 错误翻译: `Resource warning, resource growth rate: ⟦__PH_CURLY_1__⟧⟦__PH_CURLY_2__⟧/s, expected to run out of resources in ⟦__PH_CURLY_3__⟧⟦__PH_CURLY_4__⟧, resource warning value: ⟦__PH_CURLY_5__⟧⟦__PH_CURLY_6__⟧, warning calculation time [⟦__PH_CURLY_7__⟧-⟦__PH_CURLY_8__⟧]`
- 验证错误: `不可区分占位符丢失或被改写: __PH_CURLY_0__`

### 根本原因分析

#### 1. 首字母大写规则冲突
**prompt-single.md 第24行:**
```
10. **首字母大写规则**：翻译的第一个单词的首字母必须大写
```

这条规则没有考虑占位符token的情况，模型可能理解为：
- "跳过占位符，找到第一个实际单词并大写"
- 导致模型在处理时忽略或删除句首的占位符token

**prompt-batch.md 第24行（较好的版本）:**
```
10. **首字母大写规则**：若英文翻译直接以单词开头，则第一个单词首字母必须大写；若翻译以占位符（如 `{}`、`{:.3f}`、`%1`、`[{}]` 等）开头，则后面出现的第一个单词可以小写
```

但这个版本仍有问题：
- 只列举了原始占位符格式（`{}`、`{:.3f}`等）
- **没有明确提及占位符token**（`⟦__PH_CURLY_X__⟧`）
- 模型可能认为占位符token不属于"占位符"范畴

#### 2. 占位符token识别不明确
在规则2.1中提到了占位符token，但在规则10中没有再次强调，导致：
- 模型在应用首字母大写规则时，可能忘记占位符token的存在
- 规则之间缺乏关联性，模型难以建立"占位符token也是占位符"的认知

### 解决方案

#### 方案A: 增强首字母大写规则（推荐）

**修改 prompt-single.md 和 prompt-batch.md 的规则10:**

```markdown
10. **首字母大写规则**：
   - 若英文翻译以**占位符token**（`⟦__PH_CURLY_X__⟧`）或**原始占位符**（`{}`、`{:.3f}`、`%1`、`[{}]`等）开头，**必须保留该占位符**，后续第一个单词可以小写
   - 若英文翻译直接以单词开头，则第一个单词首字母必须大写
   - **关键**: 占位符token `⟦__PH_CURLY_X__⟧` 必须被视为占位符，不可跳过或删除
```

**优点:**
- 明确将占位符token纳入占位符范畴
- 强调"必须保留"，防止模型跳过
- 与规则2.1形成呼应

#### 方案B: 在规则2.1中增加句首特别提醒

**在规则2.1中添加子规则:**

```markdown
2.1 **占位符token强约束（最高优先级）**：输入词条中可能包含形如 `⟦__PH_CURLY_0__⟧` 的占位符token（含左右边界符号 `⟦` 和 `⟧`）。这些token必须：
   - **逐字原样保留**（包括 `⟦`、`⟧`、下划线与数字），禁止改写、加空格、拆分、合并
   - **按输入中出现的顺序原序输出**（禁止换序/挪位）
   - **句首占位符特别注意**: 若占位符token位于句首（如 `⟦__PH_CURLY_0__⟧ 资源预警...`），翻译时**必须保持其在句首位置**，不可因首字母大写规则而删除或跳过
```

**优点:**
- 在最高优先级规则中直接解决问题
- 明确指出句首场景
- 与首字母大写规则形成明确的优先级关系

#### 方案C: 综合方案（最推荐）

同时应用方案A和方案B，形成双重保障：
1. 在规则2.1中强调句首占位符不可删除
2. 在规则10中明确占位符token属于占位符范畴

---

## 问题2: 不同样式占位符顺序变化

### 问题描述
当文本中同时包含结构性括号和占位符token时，翻译后占位符token的顺序发生变化。

**示例:**
- 原文: `计算目标[⟦__PH_CURLY_0__⟧]中计算对象[⟦__PH_CURLY_1__⟧]包含的表达式 "⟦__PH_CURLY_2__⟧" 中因子[⟦__PH_CURLY_3__⟧]不存在`
- 错误翻译: `The expression "⟦__PH_CURLY_2__⟧" in the calculation object [⟦__PH_CURLY_1__⟧] of the calculation target [⟦__PH_CURLY_0__⟧] contains a factor [⟦__PH_CURLY_3__⟧] that does not exist`
- 验证错误: `不可区分占位符顺序发生变化（禁止）`
- 顺序变化: 原始 0→1→2→3，翻译后 2→1→0→3

### 根本原因分析

#### 1. 规则8的"不可区分占位符"定义混淆

**prompt-single.md 和 prompt-batch.md 第20行:**
```markdown
- **不可区分占位符（以花括号为准）**：任何花括号占位符（如 `{}`、`{:.3f}`）都不可换序、不可改写；外层 `[]`、`【】`、空格、连字符等只是样式，不影响"花括号占位符序列必须保序"
```

**问题分析:**

1. **概念混淆**: 规则说"外层 `[]`、`【】`等只是样式"，但在实际文本中：
   - `[⟦__PH_CURLY_0__⟧]` 中的 `[]` 是**中文原文的结构性括号**（如"计算目标[xxx]"）
   - 不是占位符的"样式"，而是原文语法的一部分

2. **误导模型**: 模型可能理解为：
   - "只要保持花括号占位符的顺序就行，`[]` 可以随意移动"
   - 但实际上，占位符token `⟦__PH_CURLY_X__⟧` 本身就是完整的占位符，不存在"花括号"

3. **规则不适用**: 这条规则原本是为了处理 `{}` vs `[{}]` 的情况（如 `{:.3f}` 和 `[{:.3f}]`），但：
   - 实际文本中的占位符是 `⟦__PH_CURLY_X__⟧`，不是 `{}`
   - 文本中的 `[]` 是中文原文的一部分，不是占位符的包装

4. **英文语序诱惑**: 英文自然语序是 "The expression X in object Y of target Z"，模型为了让翻译更自然，会调整语序，认为只要占位符token本身不变就符合规则

#### 2. 规则2.1的"原序输出"未充分强调

规则2.1说"按输入中出现的顺序原序输出"，但：
- 没有明确说明"原序"是指在整个句子中的出现顺序
- 模型可能理解为"占位符token内部的字符顺序"而非"占位符token之间的相对顺序"

### 解决方案

#### 方案A: 重写规则8，消除混淆（推荐）

**完全重写规则8:**

```markdown
8. **占位符顺序强约束（最高优先级）**：
   - **所有占位符token**（`⟦__PH_CURLY_X__⟧`）在翻译后必须保持与原文**完全相同的出现顺序**
   - **禁止调整语序**: 即使英文自然语序不同，也**不允许**为了语句通顺而改变占位符token的顺序
   - **示例**:
     - ✅ 正确: `计算目标[⟦__PH_CURLY_0__⟧]中对象[⟦__PH_CURLY_1__⟧]` → `Target [⟦__PH_CURLY_0__⟧] object [⟦__PH_CURLY_1__⟧]` (保持0→1顺序)
     - ❌ 错误: `计算目标[⟦__PH_CURLY_0__⟧]中对象[⟦__PH_CURLY_1__⟧]` → `Object [⟦__PH_CURLY_1__⟧] of target [⟦__PH_CURLY_0__⟧]` (变成1→0，禁止)
   - **原始占位符规则**: 对于未被token化的原始占位符（`{}`、`{:.3f}`等），同样必须保持原序；外层 `[]`、`【】` 等包装符号可以调整为英文格式，但占位符本身的顺序不可变
```

**优点:**
- 完全消除"样式"概念的混淆
- 明确区分占位符token和原始占位符
- 提供正反示例，直观易懂
- 强调"禁止调整语序"，防止模型为了自然度而改变顺序

#### 方案B: 增强规则2.1的顺序约束

**在规则2.1中添加明确说明:**

```markdown
2.1 **占位符token强约束（最高优先级）**：输入词条中可能包含形如 `⟦__PH_CURLY_0__⟧` 的占位符token（含左右边界符号 `⟦` 和 `⟧`）。这些token必须：
   - **逐字原样保留**（包括 `⟦`、`⟧`、下划线与数字），禁止改写、加空格、拆分、合并
   - **按输入中出现的顺序原序输出**（禁止换序/挪位）
     - **"原序"定义**: 指占位符token在整个句子中的出现顺序，如原文中依次出现 `⟦__PH_CURLY_0__⟧`、`⟦__PH_CURLY_1__⟧`、`⟦__PH_CURLY_2__⟧`，则翻译后也必须按 0→1→2 的顺序出现
     - **禁止为语序调整**: 即使英文自然语序需要调整句子结构，占位符token的相对顺序也不可改变
     - **示例**: `A[⟦__PH_CURLY_0__⟧]中B[⟦__PH_CURLY_1__⟧]` 不可翻译为 `B[⟦__PH_CURLY_1__⟧] in A[⟦__PH_CURLY_0__⟧]`（顺序变为1→0）
```

**优点:**
- 在最高优先级规则中直接解决问题
- 明确定义"原序"的含义
- 提供具体示例说明禁止的行为

#### 方案C: 添加翻译策略指导

**在规则8之后添加新规则:**

```markdown
8.1 **占位符顺序保持策略**：
   - 当遇到包含多个占位符token的复杂句子时，优先采用**保持原文结构**的翻译策略，而非追求最自然的英文语序
   - 如果必须调整语序，应通过**改写句子结构**（如使用被动语态、调整从句位置等）来保持占位符顺序不变
   - **翻译质量优先级**: 占位符顺序正确性 > 英文自然度
```

**优点:**
- 提供翻译策略指导
- 明确优先级，帮助模型在冲突时做出正确选择
- 给出替代方案（改写句子结构）

#### 方案D: 综合方案（最推荐）

同时应用方案A、B、C：
1. **重写规则8**（方案A）：消除"样式"混淆，明确占位符顺序约束
2. **增强规则2.1**（方案B）：在最高优先级规则中定义"原序"
3. **添加翻译策略**（方案C）：指导模型如何在保持顺序的前提下翻译

---

## 实施建议

### 立即修改（高优先级）

1. **修改 prompt-single.md:**
   - 更新规则10（首字母大写规则）- 解决问题1
   - 重写规则8（占位符顺序约束）- 解决问题2
   - 增强规则2.1（添加句首和原序说明）- 双重保障

2. **修改 prompt-batch.md:**
   - 应用与 prompt-single.md 相同的修改

### 测试验证

使用以下测试用例验证修改效果：

**测试用例1 - 句首占位符:**
```
⟦__PH_CURLY_0__⟧ 资源预警，资源增长速度：⟦__PH_CURLY_1__⟧⟦__PH_CURLY_2__⟧/s
```
期望翻译（保持0→1→2顺序，0在句首）:
```
⟦__PH_CURLY_0__⟧ resource warning, resource growth rate: ⟦__PH_CURLY_1__⟧⟦__PH_CURLY_2__⟧/s
```

**测试用例2 - 复杂顺序:**
```
计算目标[⟦__PH_CURLY_0__⟧]中计算对象[⟦__PH_CURLY_1__⟧]包含的表达式 "⟦__PH_CURLY_2__⟧" 中因子[⟦__PH_CURLY_3__⟧]不存在
```
期望翻译（保持0→1→2→3顺序）:
```
Factor [⟦__PH_CURLY_3__⟧] does not exist in expression "⟦__PH_CURLY_2__⟧" contained in calculation object [⟦__PH_CURLY_1__⟧] of calculation target [⟦__PH_CURLY_0__⟧]
```
注意：虽然英文自然语序是倒序，但必须通过句子结构调整来保持占位符顺序

### 长期优化建议

1. **建立占位符测试集**: 收集所有出现过占位符顺序错误的案例，形成回归测试集

2. **考虑分离规则**: 将占位符相关规则独立成一个章节，提高可读性和优先级

3. **添加更多示例**: 在规则中添加更多正反示例，特别是复杂场景

4. **监控翻译质量**: 定期检查翻译结果，及时发现新的占位符问题模式

---

## 附录：修改后的完整规则示例

### 规则2.1（增强版）

```markdown
2.1 **占位符token强约束（最高优先级）**：输入词条中可能包含形如 `⟦__PH_CURLY_0__⟧` 的占位符token（含左右边界符号 `⟦` 和 `⟧`）。这些token必须：
   - **逐字原样保留**（包括 `⟦`、`⟧`、下划线与数字），禁止改写、加空格、拆分、合并
   - **按输入中出现的顺序原序输出**（禁止换序/挪位）
     - **"原序"定义**: 指占位符token在整个句子中的出现顺序，如原文中依次出现 `⟦__PH_CURLY_0__⟧`、`⟦__PH_CURLY_1__⟧`、`⟦__PH_CURLY_2__⟧`，则翻译后也必须按 0→1→2 的顺序出现
     - **禁止为语序调整**: 即使英文自然语序需要调整句子结构，占位符token的相对顺序也不可改变
   - **句首占位符特别注意**: 若占位符token位于句首，翻译时**必须保持其在句首位置**，不可因首字母大写规则而删除或跳过
```

### 规则8（重写版）

```markdown
8. **占位符顺序强约束（最高优先级）**：
   - **所有占位符token**（`⟦__PH_CURLY_X__⟧`）在翻译后必须保持与原文**完全相同的出现顺序**
   - **禁止调整语序**: 即使英文自然语序不同，也**不允许**为了语句通顺而改变占位符token的顺序
   - **示例**:
     - ✅ 正确: `目标[⟦__PH_CURLY_0__⟧]中对象[⟦__PH_CURLY_1__⟧]` → `Target [⟦__PH_CURLY_0__⟧] object [⟦__PH_CURLY_1__⟧]` (保持0→1)
     - ❌ 错误: `目标[⟦__PH_CURLY_0__⟧]中对象[⟦__PH_CURLY_1__⟧]` → `Object [⟦__PH_CURLY_1__⟧] of target [⟦__PH_CURLY_0__⟧]` (变成1→0)
   - **原始占位符规则**: 对于未被token化的原始占位符（`{}`、`{:.3f}`等），同样必须保持原序
   - **翻译策略**: 当遇到多个占位符时，优先保持原文结构；如需调整语序，应通过改写句子结构（被动语态、从句调整等）来保持占位符顺序
```

### 规则10（增强版）

```markdown
10. **首字母大写规则**：
   - 若英文翻译以**占位符token**（`⟦__PH_CURLY_X__⟧`）或**原始占位符**（`{}`、`{:.3f}`、`%1`、`[{}]`等）开头，**必须保留该占位符**，后续第一个单词可以小写
   - 若英文翻译直接以单词开头，则第一个单词首字母必须大写
   - **关键**: 占位符token `⟦__PH_CURLY_X__⟧` 必须被视为占位符，不可跳过或删除
```

---

## 总结

两个问题的核心原因都是**规则表述不够明确和具体**：

1. **问题1（句首占位符丢失）**: 首字母大写规则没有明确包含占位符token，导致模型跳过句首占位符
2. **问题2（占位符顺序变化）**: "不可区分占位符"规则引入了"样式"概念，混淆了占位符token和原文结构性括号的区别

**解决方案的关键**：
- 在多个规则中**重复强调**占位符token的约束（规则2.1、规则8、规则10）
- 使用**明确的示例**（正反对比）而非抽象描述
- 建立**明确的优先级**（占位符正确性 > 英文自然度）
- **消除歧义概念**（如"样式"），使用精确的术语
