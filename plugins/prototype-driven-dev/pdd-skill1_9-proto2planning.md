---
name: pdd-skill1_9-proto2planning
description: "从原型到真实代码的实现规划。基于原子任务列表或原型代码，生成结构化的实现规划文档，明确范围、阶段、任务、风险点与验证方案。采用对话式流程，逐步细化设计。"
---

# Skill 1_9：从原型到真实代码的实现规划

## 概述

- **所属阶段**：S2「原型评审 / 落地规划」
- **目标**：在已经有可运行前端原型或原子任务列表的前提下，**不急于直接改业务源码**，而是通过对话式流程，逐步生成一份结构化的「从原型迁移到正式代码」实现规划（planning），明确：范围、阶段、拆分任务、风险点与验证方案。
- **执行者**：Cursor（Senior Frontend Architect）
- **输入**：
  - **方式一（推荐）**：原子任务列表（来自 `pdd-skill1_7-proto2planning` 和 `pdd-skill1_8-proto2planning` 的输出）
  - **方式二**：已存在的原型代码（通常在 `prototype/<feature-key>/` 下，如 `PrototypePage.vue`、`XXXPrototype.vue`、`mockUtils.js` 等）
  - 对应的原型设计需求文档（如 `prototype/<feature-key>/原型设计需求.md`，可选但强烈推荐）
  - 目标业务页面/模块位置（如 `src/views/entry/productEntry.vue`）
- **输出**：
  - 一份结构化、可执行的 **「原型 → 正式实现」中文规划文档**，通常建议放在 `docs/plans/` 目录下，例如：
    - `docs/plans/YYYY-MM-DD-<feature-name>-design.md`

---

## 定位与与其它 Skills 的关系

- **前置 Skill**：
  - `pdd-skill1_7-proto2planning`：分析代码更改，划分原子任务（推荐路径）
  - `pdd-skill1_8-proto2planning`：补充原子任务内容（推荐路径）
  - `pdd-skill1-prototype`：生成原型代码（备选路径）
- **并行 Skill**：`using-superpowers`、`brainstorming`、`writing-plans`
  - 本 Skill 实际上是将这些「流程类 Skill」在前端原型场景中的具体化与封装：
    - 用 brainstorming 思路梳理原型的功能范围与差异点（对话式逐步细化）
    - 用 writing-plans 思路把「迁移步骤」结构化成阶段与任务
- **后续 Skill**：
  - `pdd-skill2-api`：在规划中会指明哪些部分需要输出/更新 API 契约
  - `pdd-skill3-dev`（或类似「从原型接入真实接口」的 Skill）：规划会拆出哪些任务属于「替换 MOCK / 接入真实接口」

> **重要心态**：本 Skill 的产物是「作战计划」，不是立刻改代码。采用对话式流程，逐步细化设计，你可以先多次迭代计划，确认范围与风险，再进入真正的开发/重构阶段。

---

## 触发方式

- **推荐触发关键词**：
  - `@pdd-skill1_9-proto2planning`
  - `@pdd-proto2planning`
  - `@plan 原型转正式实现`

- **示例 1：基于原子任务列表生成规划（推荐）**

> `@pdd-skill1_9-proto2planning 基于原子任务列表（来自 pdd-skill1_7 和 pdd-skill1_8 的输出），生成一份完整的原型实现规划文档，保存到 docs/plans/ 目录。`

- **示例 2：基于原型代码生成规划**

> `@pdd-skill1_9-proto2planning 基于 prototype/writeBackValidate 目录下的原型组件，生成一份"从原型到正式代码"的实现规划，规划文件放在 docs/plans/ 目录下，用中文写。`

- **示例 3：只针对某个原型组件做落地规划**

> `@pdd-skill1_9-proto2planning 只针对 prototype/writeBackValidate/writeBackButton.vue 这个原型组件，规划如何安全迁移到 src/views/entry/productEntry.vue 中，包括阶段划分、任务拆解和风险点。`

- **示例 4：带上目标业务页面**

> `@pdd-skill1_9-proto2planning 原型在 prototype/writeBackValidate，目标业务页是 src/views/entry/productEntry.vue，请生成一份详细计划，说明哪些逻辑留在原型、哪些要迁移到正式页面或 utils/service。`

---

## Skill 内部工作流

> **角色**：Senior Frontend Architect / Tech Lead  
> **目标**：通过对话式流程，逐步细化设计，输出「可以拿去开评审会」级别的实现规划，而不是琐碎的 Todo 列表。

### 流程概述

本 Skill 采用 **对话式流程**，参考 `brainstorming` skill 的方法：

1. **理解阶段**：一次一个问题，逐步收集上下文
2. **探索阶段**：提出 2-3 种方案，给出推荐
3. **呈现阶段**：分小节呈现设计（每节 200-300 字），每节后确认
4. **文档化阶段**：将确认的设计写入规划文档

### 步骤 1：理解输入（Understanding Input）

**首先确认输入来源**：

1. **如果输入是原子任务列表**（推荐路径）：
   - 读取原子任务列表文档
   - 理解任务分组和任务关系
   - 识别核心功能模块

2. **如果输入是原型代码**（备选路径）：
   - 读取原型目录结构与核心文件：
     - `prototype/<feature-key>/PrototypePage.vue`
     - 原型核心组件（如 `writeBackButton.vue`、`WriteBackValidateModal.vue`）
     - 原型专属 `mockUtils.js` / `mock.js` / `constants.js` / `utils/` / `http/`
   - 读取原型设计需求文档（如存在）：
     - `prototype/<feature-key>/原型设计需求.md`
     - 明确原型到底解决了哪些痛点、有哪些非功能性要求（性能、权限、风险控制等）

3. **读取目标业务页面/模块**（若用户有指定）：
   - 如：`src/views/entry/productEntry.vue`
   - 关注：已有的按钮区、表格区、状态管理与 API 调用位置。

> **对话式提问**：如果信息不足，一次问一个问题，例如：
> - "目标业务页面是哪个？如果没有指定，是否需要新建页面？"
> - "原型代码中哪些功能是必须保留的，哪些可以简化？"

> 若找不到业务目标文件或需求文档，要在规划中显式标记为「待确认」，不要强行假设。

### 步骤 2：范围界定与差异分析（Scope & Gap Analysis）

**对话式提问**（一次一个问题）：

1. **第一个问题**：功能范围确认
   > "原型中包含哪些核心功能？请按优先级排序：必须保留、可选保留、可以删除。"

2. **第二个问题**：目标位置确认
   > "这些功能要迁移到哪个页面/模块？是现有页面还是新建页面？"

3. **第三个问题**：差异识别
   > "正式页面中是否已有类似功能？如果有，是替换还是合并？"

**基于回答，整理「范围与对象」章节**，至少包含：

- **原型范围**：列出当前原型目录下会参与迁移的文件与组件，以及它们的大致职责。
- **目标范围**：列出目标业务页面/模块（含路径）和相关依赖模块（store、service、utils 等）。
- **差异清单**：
  - 原型多出来的功能/按钮/开关（正式环境是否需要全部保留？）
  - 正式页面已有但原型尚未覆盖的场景（迁移时要避免功能倒退）
  - 状态管理方式差异（本地 data vs Vuex/Pinia/其他 store）

**呈现方式**：先呈现「范围与对象」章节（200-300 字），询问："这个范围界定是否准确？"

### 步骤 3：阶段性规划（Phased Plan）

**探索阶段**：提出 2-3 种阶段划分方案

**方案 1：按功能模块划分**（适合功能独立的情况）
- 阶段 A：核心功能模块 1
- 阶段 B：核心功能模块 2
- ...

**方案 2：按开发流程划分**（推荐，适合大多数情况）
- 阶段 A：原型代码盘点与整理
- 阶段 B：接口与数据流对齐（原型 vs 真实接口）
- 阶段 C：模式与行为设计（如 isPrototype / submitMode / mode）
- 阶段 D：组件迁移与重构（挂到正式页面/模块）
- 阶段 E：业务逻辑落地（如回写前校验 / 风险控制流程）
- 阶段 F：外围流程接入（Git / 审批 / 审计等）
- 阶段 G：测试、联调与回归验证

**方案 3：按原子任务分组**（如果输入是原子任务列表）
- 基于任务组 A、B、C... 自然划分阶段

**推荐方案**：方案 2（按开发流程划分），因为：
- 符合开发的自然顺序
- 每个阶段有明确的产出物
- 便于并行开发和评审

**对话式确认**："你倾向于哪种阶段划分方式？或者有其他建议？"

**基于确认，整理「总体阶段规划」章节**，每个阶段要说明：

- 阶段目标（一句话）
- 关键产出物（代码/文档）
- 是否需要联调/评审
- 依赖关系（哪些阶段可以并行，哪些必须串行）

**呈现方式**：先呈现「总体阶段规划」章节（200-300 字），询问："这个阶段划分是否合理？"

### 步骤 4：按文件/模块拆解任务（Task Breakdown）

**如果输入是原子任务列表**：
- 直接基于原子任务列表，将任务映射到具体文件和实现步骤
- 每个原子任务对应一个或多个实现任务

**如果输入是原型代码**：
- 分析原型代码结构，识别需要迁移/重构的组件和逻辑
- 将功能拆解成原子任务，再映射到实现任务

**对话式确认**："任务拆解的粒度如何？每个任务预计耗时多少？"

**整理「落地到具体文件的改造任务」章节**，对每个关键文件给出**任务卡片式**描述，例如：

- **任务 X：规范 `writeBackButton.vue` 中的模式控制与参数构建**
  - 修改/依赖文件：
    - `prototype/writeBackValidate/writeBackButton.vue`
    - `src/views/entry/productEntry.vue`
  - 任务目标：
    - 明确 props（如 `mode`、`submitMode`、`enableValidation`、`isPrototype`）的语义与默认值。
    - 抽取重复逻辑到辅助方法（如参数构建、表单校验、Git 参数生成）。
  - 潜在风险 / 注意事项：
    - props 语义可能与其他组件冲突，需要统一命名规范。
    - 抽取逻辑时要注意保持原有功能不变。
  - 验收标准：
    - 原型页与正式页行为一致。
    - 通过指定测试场景（例如「多语种回写且开启校验与 Git 推送」）。

要求每个任务至少包含：

- **修改/依赖文件列表**
- **任务目标**
- **潜在风险 / 注意事项**
- **简单验收标准**

**呈现方式**：按阶段分组呈现任务，每阶段后询问："这个阶段的任务是否完整？"

### 步骤 5：关键决策点与风险（Decision & Risk）

**对话式提问**（一次一个问题）：

1. **第一个问题**：原型页保留策略
   > "原型页在开发完成后是否需要保留？用于演示、测试还是直接删除？"

2. **第二个问题**：模式控制策略
   > "是否需要支持原型模式（isPrototype）？在不同环境如何控制？"

3. **第三个问题**：异常处理策略
   > "遇到部分成功/全部失败的情况，如何处理？用户提示策略是什么？"

**整理「关键设计决策点」章节**，总结实现前需要敲定的关键决策，包括但不限于：

- 是否保留原型页（长期演示 vs 开发完删除）
- 原型模式（`isPrototype`）在不同环境的默认值与开启方式
- 多语言/多来源场景下的「部分成功/全部成功」判定策略
- Git/审批/权限相关的边界情况与兜底策略

对于每个决策点：

- 给出 1–2 个可选方案
- 简要优缺点
- 标记推荐方案（若信息不足，则标记为「待业务确认」）

**呈现方式**：先呈现「关键设计决策点」章节（200-300 字），询问："这些决策点是否需要调整？"

### 步骤 6：验证计划（Verification Plan）

**对话式提问**：

1. **第一个问题**：测试覆盖范围
   > "需要覆盖哪些测试场景？功能测试、异常测试、回归测试？"

2. **第二个问题**：测试优先级
   > "哪些场景是必须测试的，哪些是可选的？"

**整理「验证计划」章节**，按场景列出需要覆盖的测试/验证步骤，例如：

- **功能场景**：
  - 单语言回写 / 多语言回写
  - 有/无「回写前校验」
  - 有/无「回写后 Git 提交/推送」
- **异常场景**：
  - 接口失败 / 超时
  - 部分语种失败
  - 无可回写数据
- **回归场景**：
  - 确认原有导入/导出/筛选等老功能未被破坏

> **注意**：这里只写「计划」，不直接去写测试代码；真正写测试时可以配合项目内的 `plan-test-analysis` 等 Skill。

**呈现方式**：先呈现「验证计划」章节（200-300 字），询问："测试计划是否完整？"

---

### 步骤 7：文档化（Documentation）

**在对话确认所有章节后**，将完整规划写入文档：

1. **保存位置**：
   - 推荐：`docs/plans/YYYY-MM-DD-<feature-name>-design.md`
   - 备选：`prototype/<feature-key>/原型实现规划-<模块名>.md`

2. **文档结构**（参考 `writing-plans` skill 的格式）：
   ```markdown
   # [Feature Name] Implementation Plan
   
   > **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.
   
   **Goal:** [One sentence describing what this builds]
   
   **Architecture:** [2-3 sentences about approach]
   
   **Tech Stack:** [Key technologies/libraries]
   
   ---
   
   ## 一、范围与对象
   ...
   
   ## 二、总体阶段规划
   ...
   
   ## 三、关键设计决策点（需要在实现前确认）
   ...
   
   ## 四、落地到具体文件的改造任务
   ...
   
   ## 五、验证计划
   ...
   
   ## 六、交付物
   ...
   ```

3. **使用项目内既有的术语风格与文件路径**，避免抽象化命名。

4. **提交到 Git**（可选）：
   ```bash
   git add docs/plans/YYYY-MM-DD-<feature-name>-design.md
   git commit -m "docs: add implementation plan for <feature-name>"
   ```

---

### 与「代码重构最佳实践规则」的衔接

在规划中，遇到需要重构/迁移的组件（如 `methods` 很多、存在大量重复逻辑）时，应主动引用并应用仓库中约定的重构规则，例如：

- 在规划中明确：
  - 需要对 `methods` 进行分组注释（生命周期/交互控制/数据操作/业务逻辑/辅助方法）。
  - 哪些重复逻辑需要提取为辅助方法（如 `extractXxx`、`validateXxx`、`transformXxx` 等）。
- 在具体任务中，写清：
  - 哪些方法将被抽取到 `utils/` 或 service 层。
  - 抽取后的复用关系（例如「回写按钮与导入按钮共享同一验证工具函数」）。

> 这样可以确保：本 Skill 产出的规划，天然符合你项目的重构规范，而不是额外多一套标准。

---

## 关键原则

参考 `brainstorming` skill 的原则：

- **一次一个问题** - 不要一次性问多个问题，逐步细化
- **多选优先** - 当可能时，提供多个选项让用户选择
- **分节呈现** - 每节 200-300 字，每节后确认
- **灵活迭代** - 如果某部分不对，回到对应步骤重新讨论
- **YAGNI** - 移除不必要的功能，保持规划简洁

## 最佳实践与使用建议

- **何时使用本 Skill**：
  - 当原型已经能跑通主要交互，但你还没想好如何安全地并入现有复杂页面/业务时。
  - 当需要对接后端/测试/运维，开一个「落地方案评审会」之前。
  - 当有原子任务列表，需要生成完整实现规划时（推荐路径）。

- **如何迭代规划**：
  - 采用对话式流程，逐步细化每个章节
  - 可以多次触发本 Skill，每次在已有规划文档基础上增量更新
  - 适合在每次评审/讨论后，用自然语言告诉 Cursor 哪些决策有更新，让本 Skill 重新生成/修订对应章节

- **如何与其它 Skill 协作**：
  - **推荐路径**：`pdd-skill1_7` → `pdd-skill1_8` → `pdd-skill1_9`（本 Skill）
  - 确认规划后，再用 `pdd-skill2-api` 生成/更新 OpenAPI 契约
  - 接着用「开发/接入真实接口」类 Skill 实际修改代码
  - 最后用 `verification-before-completion` / 测试相关 Skill 做一次系统性验收

- **执行选择**（参考 `writing-plans` skill）：
  - 规划完成后，提供执行选择：
    - **子代理驱动**（当前会话）：分派子代理逐任务执行，任务间审查
    - **并行会话**（新会话）：在新会话中使用 `executing-plans` skill，批量执行并设置检查点

