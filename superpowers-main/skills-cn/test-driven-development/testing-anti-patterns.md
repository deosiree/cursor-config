# 测试反模式

**在以下情况加载此参考：** 编写或更改测试、添加模拟，或想要向生产代码添加仅测试方法时。

## 概述

测试必须验证真实行为，而不是模拟行为。模拟是隔离的手段，不是被测试的内容。

**核心原则：** 测试代码做什么，而不是模拟做什么。

**遵循严格的 TDD 可以防止这些反模式。**

## 铁律

```
1. 绝不测试模拟行为
2. 绝不向生产类添加仅测试方法
3. 绝不在不理解依赖项的情况下模拟
```

## 反模式 1：测试模拟行为

**违反：**
```typescript
// ❌ 错误：测试模拟存在
test('渲染侧边栏', () => {
  render(<Page />);
  expect(screen.getByTestId('sidebar-mock')).toBeInTheDocument();
});
```

**为什么这是错误的：**
- 你正在验证模拟有效，而不是组件有效
- 当模拟存在时测试通过，不存在时失败
- 告诉你关于真实行为的任何信息

**你合作伙伴的纠正：** "我们是在测试模拟的行为吗？"

**修复：**
```typescript
// ✅ 好：测试真实组件或不模拟它
test('渲染侧边栏', () => {
  render(<Page />);  // 不要模拟侧边栏
  expect(screen.getByRole('navigation')).toBeInTheDocument();
});

// 或者如果必须为隔离模拟侧边栏：
// 不要断言模拟 - 测试侧边栏存在时页面的行为
```

### 门控函数

```
在断言任何模拟元素之前：
  问："我是在测试真实组件行为还是只是模拟存在？"

  如果测试模拟存在：
    停止 - 删除断言或取消模拟组件

  改为测试真实行为
```

## 反模式 2：生产中的仅测试方法

**违反：**
```typescript
// ❌ 错误：destroy() 仅在测试中使用
class Session {
  async destroy() {  // 看起来像生产 API！
    await this._workspaceManager?.destroyWorkspace(this.id);
    // ... 清理
  }
}

// 在测试中
afterEach(() => session.destroy());
```

**为什么这是错误的：**
- 生产类被仅测试代码污染
- 如果在生产中意外调用则危险
- 违反 YAGNI 和关注点分离
- 混淆对象生命周期与实体生命周期

**修复：**
```typescript
// ✅ 好：测试工具处理测试清理
// Session 没有 destroy() - 在生产中它是无状态的

// 在 test-utils/
export async function cleanupSession(session: Session) {
  const workspace = session.getWorkspaceInfo();
  if (workspace) {
    await workspaceManager.destroyWorkspace(workspace.id);
  }
}

// 在测试中
afterEach(() => cleanupSession(session));
```

### 门控函数

```
在向生产类添加任何方法之前：
  问："这仅由测试使用吗？"

  如果是：
    停止 - 不要添加它
    改为将其放在测试工具中

  问："此类拥有此资源的生命周期吗？"

  如果不是：
    停止 - 此方法的错误类
```

## 反模式 3：在不理解的情况下模拟

**违反：**
```typescript
// ❌ 错误：模拟破坏测试逻辑
test('检测重复服务器', () => {
  // 模拟阻止测试依赖的配置写入！
  vi.mock('ToolCatalog', () => ({
    discoverAndCacheTools: vi.fn().mockResolvedValue(undefined)
  }));

  await addServer(config);
  await addServer(config);  // 应该抛出 - 但不会！
});
```

**为什么这是错误的：**
- 模拟的方法有测试依赖的副作用（写入配置）
- 过度模拟以"安全"破坏实际行为
- 测试因错误原因通过或神秘失败

**修复：**
```typescript
// ✅ 好：在正确级别模拟
test('检测重复服务器', () => {
  // 只模拟慢的部分，保留测试需要的行为
  vi.mock('MCPServerManager'); // 只模拟慢的服务器启动

  await addServer(config);  // 配置已写入
  await addServer(config);  // 检测到重复 ✓
});
```

### 门控函数

```
在模拟任何方法之前：
  停止 - 暂时不要模拟

  1. 问："真实方法有什么副作用？"
  2. 问："此测试是否依赖任何这些副作用？"
  3. 问："我完全理解此测试需要什么吗？"

  如果依赖副作用：
    在较低级别模拟（实际的慢/外部操作）
    或使用保留必要行为的测试替身
    不是测试依赖的高级方法

  如果不确定测试依赖什么：
    首先使用真实实现运行测试
    观察实际需要发生什么
    然后在正确级别添加最少模拟

  危险信号：
    - "我会模拟这个以安全"
    - "这可能很慢，最好模拟它"
    - 在不理解依赖链的情况下模拟
```

## 反模式 4：不完整的模拟

**违反：**
```typescript
// ❌ 错误：部分模拟 - 只包含你认为需要的字段
const mockResponse = {
  status: 'success',
  data: { userId: '123', name: 'Alice' }
  // 缺少：下游代码使用的元数据
};

// 稍后：当代码访问 response.metadata.requestId 时中断
```

**为什么这是错误的：**
- **部分模拟隐藏结构假设** - 你只模拟了你知道的字段
- **下游代码可能依赖你未包含的字段** - 静默失败
- **测试通过但集成失败** - 模拟不完整，真实 API 完整
- **虚假信心** - 测试证明不了关于真实行为的任何内容

**铁律：** 模拟现实中存在的完整数据结构，不仅仅是你的立即测试使用的字段。

**修复：**
```typescript
// ✅ 好：镜像真实 API 完整性
const mockResponse = {
  status: 'success',
  data: { userId: '123', name: 'Alice' },
  metadata: { requestId: 'req-789', timestamp: 1234567890 }
  // 真实 API 返回的所有字段
};
```

### 门控函数

```
在创建模拟响应之前：
  检查："真实 API 响应包含什么字段？"

  操作：
    1. 检查文档/示例中的实际 API 响应
    2. 包含系统可能在下游消耗的所有字段
    3. 验证模拟完全匹配真实响应模式

  关键：
    如果你正在创建模拟，你必须理解整个结构
    部分模拟在代码依赖省略字段时静默失败

  如果不确定：包含所有文档字段
```

## 反模式 5：集成测试作为事后想法

**违反：**
```
✅ 实现完成
❌ 未编写测试
"准备测试"
```

**为什么这是错误的：**
- 测试是实施的一部分，不是可选的后续
- TDD 会捕获这一点
- 没有测试不能声称完成

**修复：**
```
TDD 循环：
1. 编写失败测试
2. 实施以通过
3. 重构
4. 然后声称完成
```

## 当模拟变得太复杂时

**警告信号：**
- 模拟设置比测试逻辑长
- 模拟所有内容以使测试通过
- 模拟缺少真实组件具有的方法
- 模拟更改时测试中断

**你合作伙伴的问题：** "我们需要在这里使用模拟吗？"

**考虑：** 使用真实组件的集成测试通常比复杂模拟更简单

## TDD 防止这些反模式

**为什么 TDD 有帮助：**
1. **先写测试** → 迫使你思考你实际测试的内容
2. **看它失败** → 确认测试测试真实行为，不是模拟
3. **最少实现** → 仅测试方法不会悄悄进入
4. **真实依赖** → 你在模拟之前看到测试实际需要什么

**如果你正在测试模拟行为，你违反了 TDD** - 你在没有首先看到测试对真实代码失败的情况下添加了模拟。

## 快速参考

| 反模式 | 修复 |
|--------------|-----|
| 断言模拟元素 | 测试真实组件或取消模拟它 |
| 生产中的仅测试方法 | 移动到测试工具 |
| 在不理解的情况下模拟 | 首先理解依赖项，最少模拟 |
| 不完整的模拟 | 完全镜像真实 API |
| 测试作为事后想法 | TDD - 测试优先 |
| 过度复杂的模拟 | 考虑集成测试 |

## 危险信号

- 断言检查 `*-mock` 测试 ID
- 仅在测试文件中调用的方法
- 模拟设置是测试的 >50%
- 删除模拟时测试失败
- 无法解释为什么需要模拟
- 模拟"只是为了安全"

## 底线

**模拟是隔离的工具，不是要测试的内容。**

如果 TDD 显示你正在测试模拟行为，你出错了。

修复：测试真实行为或质疑你为什么完全模拟。
