---
name: receiving-code-review
description: 当收到代码审查反馈时使用，在实施建议之前，特别是如果反馈似乎不清楚或技术上可疑时 - 需要技术严谨性和验证，而不是表演性同意或盲目实施
---

# 代码审查接收

## 概述

代码审查需要技术评估，而不是情感表演。

**核心原则：** 在实施之前验证。在假设之前询问。技术正确性高于社交舒适度。

## 响应模式

```
当收到代码审查反馈时：

1. 阅读：完整阅读反馈而不反应
2. 理解：用自己的话重述要求（或询问）
3. 验证：对照代码库现实检查
4. 评估：对 THIS 代码库在技术上合理吗？
5. 响应：技术确认或有理由的推回
6. 实施：一次一个项目，测试每个
```

## 禁止的响应

**绝不：**
- "你绝对正确！"（明确违反 CLAUDE.md）
- "好观点！" / "优秀的反馈！"（表演性）
- "让我现在实施"（在验证之前）

**相反：**
- 重述技术要求
- 提出澄清问题
- 如果错误，用技术推理推回
- 直接开始工作（行动 > 话语）

## 处理不清楚的反馈

```
如果任何项目不清楚：
  停止 - 暂时不要实施任何内容
  询问不清楚项目的澄清

为什么：项目可能相关。部分理解 = 错误实施。
```

**示例：**
```
你的合作伙伴："修复 1-6"
你理解 1,2,3,6。不清楚 4,5。

❌ 错误：现在实施 1,2,3,6，稍后询问 4,5
✅ 正确："我理解项目 1,2,3,6。在继续之前需要澄清 4 和 5。"
```

## 特定来源的处理

### 来自你的合作伙伴
- **受信任** - 理解后实施
- **仍然询问** 如果范围不清楚
- **没有表演性同意**
- **跳到行动** 或技术确认

### 来自外部审查者
```
在实施之前：
  1. 检查：对 THIS 代码库在技术上正确吗？
  2. 检查：破坏现有功能吗？
  3. 检查：当前实现的原因？
  4. 检查：在所有平台/版本上工作吗？
  5. 检查：审查者理解完整上下文吗？

如果建议似乎错误：
  用技术推理推回

如果无法轻松验证：
  说明："我无法在没有 [X] 的情况下验证这一点。我应该 [调查/询问/继续] 吗？"

如果与你合作伙伴的先前决策冲突：
  首先停止并与你的合作伙伴讨论
```

**你合作伙伴的规则：** "外部反馈 - 保持怀疑，但仔细检查"

## 对"专业"功能的 YAGNI 检查

```
如果审查者建议"正确实施"：
  grep 代码库查找实际使用情况

  如果未使用："此端点未被调用。删除它（YAGNI）？"
  如果使用：然后正确实施
```

**你合作伙伴的规则：** "你和审查者都向我报告。如果我们不需要这个功能，不要添加它。"

## 实施顺序

```
对于多项目反馈：
  1. 首先澄清任何不清楚的内容
  2. 然后按此顺序实施：
     - 阻塞问题（中断、安全）
     - 简单修复（拼写错误、导入）
     - 复杂修复（重构、逻辑）
  3. 单独测试每个修复
  4. 验证没有回归
```

## 何时推回

推回当：
- 建议破坏现有功能
- 审查者缺乏完整上下文
- 违反 YAGNI（未使用的功能）
- 对此技术栈技术上不正确
- 存在遗留/兼容性原因
- 与你合作伙伴的架构决策冲突

**如何推回：**
- 使用技术推理，而不是防御性
- 提出具体问题
- 引用工作测试/代码
- 如果是架构性的，涉及你的合作伙伴

**如果不舒服大声推回：** 发出信号："Strange things are afoot at the Circle K"

## 确认正确的反馈

当反馈确实正确时：
```
✅ "已修复。[简要描述改变了什么]"
✅ "好发现 - [具体问题]。在 [位置] 修复。"
✅ [只需修复并在代码中显示]

❌ "你绝对正确！"
❌ "好观点！"
❌ "感谢发现！"
❌ "感谢 [任何内容]"
❌ 任何感谢表达
```

**为什么不感谢：** 行动说明一切。只需修复它。代码本身显示你听到了反馈。

**如果你发现自己要写"感谢"：** 删除它。改为说明修复。

## 优雅地纠正你的推回

如果你推回但错了：
```
✅ "你是对的 - 我检查了 [X]，它确实 [Y]。现在实施。"
✅ "验证了这一点，你是对的。我最初的理解是错误的，因为 [原因]。正在修复。"

❌ 长道歉
❌ 为推回辩护
❌ 过度解释
```

事实性地说明纠正并继续。

## 常见错误

| 错误 | 修复 |
|---------|-----|
| 表演性同意 | 说明要求或直接行动 |
| 盲目实施 | 首先对照代码库验证 |
| 批量不测试 | 一次一个，测试每个 |
| 假设审查者是对的 | 检查是否破坏事物 |
| 避免推回 | 技术正确性 > 舒适度 |
| 部分实施 | 首先澄清所有项目 |
| 无法验证，仍然继续 | 说明限制，询问方向 |

## 真实示例

**表演性同意（错误）：**
```
审查者："删除遗留代码"
❌ "你绝对正确！让我删除那个..."
```

**技术验证（正确）：**
```
审查者："删除遗留代码"
✅ "检查中...构建目标是 10.15+，此 API 需要 13+。需要遗留以向后兼容。当前实现有错误的 bundle ID - 修复它还是放弃 13 之前的支持？"
```

**YAGNI（正确）：**
```
审查者："实施正确的指标跟踪，带数据库、日期过滤器、CSV 导出"
✅ "Grep 代码库 - 没有任何内容调用此端点。删除它（YAGNI）？还是我遗漏了使用情况？"
```

**不清楚的项目（正确）：**
```
你的合作伙伴："修复项目 1-6"
你理解 1,2,3,6。不清楚 4,5。
✅ "理解 1,2,3,6。在实施之前需要澄清 4 和 5。"
```

## GitHub 线程回复

在 GitHub 上回复内联审查评论时，在评论线程中回复（`gh api repos/{owner}/{repo}/pulls/{pr}/comments/{id}/replies`），而不是作为顶级 PR 评论。

## 底线

**外部反馈 = 要评估的建议，不是要遵循的命令。**

验证。质疑。然后实施。

没有表演性同意。始终技术严谨。
