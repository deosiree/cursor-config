# 原型驱动开发-工作流

这套工作流的核心在于 **“以代码为中心的设计（Code-Centric Design）”**。我们将这个流程标准化，明确人与 AI 的分工，并为你设计一套可以直接保存到 Cursor（`.cursorrules` 或常用 Prompt 库）的 **Skills**。

## 第一部分：工作流分工与数据流转表

| 阶段 | 步骤名称 | 执行者 | 输入 (Input) | 输出 (Output) | 数据流转目标 |
| --- | --- | --- | --- | --- | --- |
| **1. 设计** | **S1. 极速原型** | **Cursor** (Skill 1) | 人工：自然语言描述需求 + 参考页面路径 | **原型目录自包含**（`prototype/<feature>/**` + `prototype/router.js`）+ **硬编码 Mock 数据** | 静态路由访问体验测试 |
| **2. 验证** | **S2. 体验测试** | **人工** | 浏览器交互体验 | 修改意见 / 确认通过 | 决定是否进入下一阶段 |
| **3. 定义** | **S3. 逆向契约** | **Cursor** (Skill 2) | 确认后的原型代码 (含数据结构) | **OpenAPI (YAML/JSON) 规范** | **Apifox** |
| **4. 托管** | **S4. 生成 Mock** | **Apifox** (工具) | OpenAPI 规范文件 | **云端 Mock URL** | 复制 URL 给 Cursor |
| **5. 开发** | **S5. 真实对接** | **Cursor** (Skill 3) | 云端 Mock URL + 原型代码 | 包含 HTTP 请求的正式代码 | 前端项目库 |

---

## 第二部分：Cursor Skills 设计 (可直接复用)

你可以将以下三个 Skills 保存为 Cursor 的 `.cursorrules` 规则，或者作为常用的 Prompt 模板（Snippet）。

### Skill 1: 🧩 Prototyping (极速原型生成)

**适用场景**：从 0 到 1 生成带交互的可视化组件，不依赖后端。
**主要逻辑**：生成 UI + 编写本地假数据 + 模拟网络延迟。

> **[Cursor Prompt Template]**
> **Role**: Senior Frontend Prototyper
> **Trigger**: "Create a prototype for [Feature Name]"
> **Guidelines**:
>
> 1. **File Structure**: Create a prototype under `prototype/<feature>/**` and add a static route entry in `prototype/router.js` so it is reachable under `/translate/...`.
> 2. **Visuals**: Prefer the project's existing component library (e.g. Ant Design Vue) and minimal inline styles. Do not introduce a new styling system unless asked.
> 3. **Data Isolation**: DO NOT write actual API calls (`axios`/`fetch`). Instead, define `MOCK_DATA` (and helpers if needed) locally.
> 4. **Interaction**: Implement full interactivity (clicks, form inputs).
> 5. **Simulation**: When a user action occurs (e.g., submit), use `setTimeout(..., 800)` to simulate network latency, show a loading spinner, then update the local state.
> 6. **Context**: The user wants to test the *feel* of the data flow. Ensure the mock data structure is realistic (include IDs, status enums, timestamps).

### Skill 2: 📜 Contract Extraction (逆向生成 API 契约)

**适用场景**：原型体验满意后，将代码里的逻辑“翻译”给后端和 Apifox。
**主要逻辑**：分析组件内的 Mock 数据和交互操作，推导出 RESTful API 规范。

> **[Cursor Prompt Template]**
> **Role**: API Architect
> **Trigger**: "Generate OpenAPI spec from this component"
> **Context**: Analyze the currently open frontend component, specifically the `MOCK_DATA` structure and the user interaction handlers (e.g., `handleSubmit`, `handleDelete`).
> **Action**: Generate a valid **OpenAPI 3.0 (YAML)** block.
> **Requirements**:
>
> 1. **Endpoints**: Infer endpoints based on actions.
>    - Read data -> `GET /api/v1/[resource]`
>    - Add data -> `POST /api/v1/[resource]`
>    - Update -> `PUT/PATCH`
>    - Delete -> `DELETE`
>
> 2. **Schema**: Create detailed schemas based on the Typescript interfaces or `MOCK_DATA` structure. Detect types (integer, string, boolean) accurately.
> 3. **Response**: Include successful responses (200) with the sample JSON structure derived from the mock data.
> 4. **Output**: Only output the YAML code block, ready for copy-pasting into Apifox.

### Skill 3: 🔌 Live Integration (对接 Mock/真实接口)

**适用场景**：Apifox 已经生成了 URL，需要把前端的“假数据”替换为“真请求”。
**主要逻辑**：移除本地 Mock 数据，引入 Axios，处理 Loading 和 Error 状态。

> **[Cursor Prompt Template]**
> **Role**: Frontend Engineer
> **Trigger**: "Refactor to use API: [Insert Mock URL]"
> **Action**: Refactor the current component to use real network requests.
> **Steps**:
>
> 1. **Cleanup**: Remove the hardcoded `MOCK_DATA` constant.
> 2. **Client Setup**: Import `axios` (or use the project's request utility).
> 3. **Implementation**:
>    - Replace the data initialization with a `onMounted` (Vue) or `useEffect` (React) hook to fetch data from the provided URL.
>    - Update button actions to send POST/PUT/DELETE requests to the URL.
> 4. **Robustness**: Add `try/catch` blocks. Add a `loading` state variable to control UI spinners. Add an `error` state to display toast notifications on failure.
> 5. **Preservation**: Keep all existing UI logic and component usage intact. Only change the data source layer.

---

## 第三部分：实际操作演示 (Walkthrough)

为了让你更清楚如何操作，这里是一个 **“人工 + AI 协同”** 的脚本：

### Step 1: 启动 (User Action)

你在 Cursor 中按下 `Cmd + I` (Composer)，输入：

> "Skill 1: Create a prototype for a 'Product Inventory Table'. It should show product image, name, stock count, and a toggle for 'On Sale'. Allow me to edit the stock count."

### Step 2: 产出与验证 (Cursor -> User)

Cursor 生成代码。你本地运行。你发现“编辑库存”时没有确认弹窗，体验不好。
你对 Cursor 说：*"Add a confirmation modal before saving the stock count."*
Cursor 修改代码。你再次测试，觉得满意。

### Step 3: 提取契约 (User -> Cursor -> Apifox)

你选中代码，打开 Chat (`Cmd + L`)，输入：

> "Skill 2: Generate OpenAPI spec from this component."

Cursor 输出一段 YAML。
**人工操作**：复制 YAML -> 打开 Apifox -> 导入 OpenAPI -> 获得 Mock URL (例如 `https://mock.apifox.com/m1/123...`)。

### Step 4: 落地 (Apifox -> Cursor)

回到 Cursor Composer，输入：

> "Skill 3: Refactor to use API: [https://mock.apifox.com/m1/123](https://www.google.com/url?sa=E&source=gmail&q=https://mock.apifox.com/m1/123)..."

**结果**：你的原型代码变成了正式的业务代码，且能直接跑通 Mock 数据。后端此时只需根据 Apifox 里的文档去实现接口即可。
