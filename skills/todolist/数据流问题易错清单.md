## 数据流问题易错清单（按问题类型分组，持续补充）

### 1. 状态变化时序问题

- **1.1 在 watch 中立即执行副作用**
  - **风险类型**：在 watch 中直接修改其他状态，但 DOM 更新是异步的，导致时序问题。
  - **典型现象**：
    - 新模态框还未渲染完成，旧模态框就已经关闭
    - 视觉上出现闪烁或不流畅
    - 测试用例期望立即关闭，但实际代码在 `$nextTick` 中关闭
  - **关键成因**：
    - watch 是同步执行的，但 DOM 更新是异步的
    - 在 watch 中直接关闭旧状态，没有等待新状态渲染完成
    - 没有使用 `$nextTick` 等待 DOM 更新完成
  - **典型代码模式**：
    ```js
    // 错误的做法
    watch: {
      validationVisible(newVal) {
        if (newVal) {
          this.internalVisible = false; // 问题：立即关闭，但新模态框还未渲染
        }
      }
    }
    ```
  - **快速检查**：
    - 检查 watch 中是否有直接修改其他状态的逻辑
    - 检查是否在设置新状态后立即关闭旧状态
    - 检查是否缺少 `$nextTick` 等待步骤
  - **修复建议**：
    - 移除 watch 中的副作用，只保留必要的响应逻辑（如 `setModalAriaHidden`）
    - 将关闭逻辑移到业务逻辑方法中，使用 `$nextTick` 控制时序
    - 遵循响应式关闭模式：接口响应 → 设置新状态 → `$nextTick` → 关闭旧状态

- **1.2 忽略异步操作的时序特性**
  - **风险类型**：接口响应后立即关闭旧状态，但新状态还未渲染完成。
  - **典型现象**：
    - 接口响应后立即关闭旧模态框，但新模态框还未显示
    - loading 状态提前关闭，但新模态框还未渲染
    - 测试用例期望立即关闭，但实际需要等待 `$nextTick`
  - **关键成因**：
    - 没有理解 Vue 的 DOM 更新是异步的
    - 设置新状态后立即执行关闭操作，没有等待 DOM 更新完成
    - 没有使用 `$nextTick` 确保 DOM 更新完成后再执行后续操作
  - **典型代码模式**：
    ```js
    // 错误的做法
    async handleValidation() {
      const result = await entryValidate_v2(...);
      this.validationVisible = true;
      this.internalVisible = false; // 问题：没有等待 DOM 更新
    }
    ```
  - **快速检查**：
    - 检查是否在设置新状态后立即关闭旧状态
    - 检查是否缺少 `$nextTick` 等待步骤
    - 检查 loading 状态是否在新模态框渲染完成后才关闭
  - **修复建议**：
    - 使用 `$nextTick` 等待 DOM 更新完成后再执行关闭操作
    - 遵循响应式关闭模式：接口响应 → 设置新状态 → `$nextTick` → 关闭旧状态
    - loading 状态管理：接口调用期间保持 loading → 新模态框渲染完成 → `$nextTick` → 关闭 loading

### 2. Loading 状态管理问题

- **2.1 Loading 状态提前关闭**
  - **风险类型**：在接口响应后立即关闭 loading，但新模态框还未渲染完成。
  - **典型现象**：
    - 接口响应后立即关闭 loading，但新模态框还未显示
    - 用户看到 loading 消失，但新模态框还未出现，体验不流畅
  - **关键成因**：
    - 在接口响应后立即设置 `loading = false`
    - 没有等待新模态框渲染完成
    - 没有使用 `$nextTick` 确保 DOM 更新完成后再关闭 loading
  - **典型代码模式**：
    ```js
    // 错误的做法
    async handleOK() {
      this.loading = true;
      await this.handleValidation();
      this.loading = false; // 问题：立即关闭，但新模态框还未渲染
    }
    ```
  - **快速检查**：
    - 检查 loading 状态是否在接口响应后立即关闭
    - 检查是否缺少 `$nextTick` 等待步骤
    - 检查 loading 状态是否在新模态框渲染完成后才关闭
  - **修复建议**：
    - 在新模态框渲染完成后再关闭 loading
    - 使用 `$nextTick` 确保 DOM 更新完成后再关闭 loading
    - 错误处理时确保 loading 被正确关闭

- **2.2 错误处理时未关闭 Loading**
  - **风险类型**：接口调用失败时，loading 状态没有被正确关闭。
  - **典型现象**：
    - 接口调用失败后，loading 状态一直保持，用户无法继续操作
    - 错误提示显示，但 loading 状态未关闭
  - **关键成因**：
    - 在 try-catch 块中忘记关闭 loading
    - 错误处理逻辑不完整
  - **典型代码模式**：
    ```js
    // 错误的做法
    async handleContinueBackFill() {
      this.loading = true;
      await this.handleBatchUpdate(); // 如果这里抛出错误，loading 不会被关闭
      this.loading = false;
    }
    ```
  - **快速检查**：
    - 检查所有异步方法是否都有错误处理
    - 检查错误处理中是否关闭了 loading
    - 检查是否使用了 try-catch 确保 loading 被正确关闭
  - **修复建议**：
    - 使用 try-catch 包裹异步操作
    - 在 catch 块中确保 loading 被正确关闭
    - 重新抛出错误，让调用方知道操作失败

### 3. 测试用例不符合实际业务逻辑

- **3.1 测试用例直接设置状态，而不是通过业务方法触发**
  - **风险类型**：测试用例直接设置状态，期望立即生效，但实际业务逻辑中状态变化是通过业务方法触发的。
  - **典型现象**：
    - 测试用例直接设置 `updateVisible = true`，期望 `validationVisible` 立即变为 `false`
    - 但实际代码中，关闭逻辑在 `handleBatchUpdate` 方法中，通过 `$nextTick` 执行
    - 测试用例失败，期望的行为与实际代码逻辑不一致
  - **关键成因**：
    - 测试用例基于旧的代码逻辑编写（watch 自动关闭）
    - 没有模拟实际的业务场景（接口调用、DOM 更新）
    - 没有考虑异步操作的时序特性
  - **典型代码模式**：
    ```js
    // 错误的测试用例
    wrapper.vm.updateVisible = true;
    await nextTick();
    expect(wrapper.vm.validationVisible).toBe(false); // 失败：期望立即关闭
    ```
  - **快速检查**：
    - 检查测试用例是否直接设置状态，而不是调用业务方法
    - 检查测试用例是否期望立即关闭的行为
    - 检查测试用例是否等待了所有异步操作完成
  - **修复建议**：
    - 测试用例应该模拟实际的业务场景（接口调用、DOM 更新）
    - 使用实际业务逻辑方法触发状态变化（如 `handleBatchUpdate`）
    - 等待所有异步操作完成（`await nextTick()`，可能需要多个 `nextTick`）

- **3.2 测试用例未等待异步操作完成**
  - **风险类型**：测试用例期望立即生效，但实际代码中使用了 `$nextTick` 延迟执行。
  - **典型现象**：
    - 测试用例在接口响应后立即检查状态，但状态变化在 `$nextTick` 中执行
    - 测试用例失败，期望的状态与实际状态不一致
  - **关键成因**：
    - 没有理解 Vue 的 DOM 更新是异步的
    - 没有等待 `$nextTick` 完成
    - 可能需要等待多个 `$nextTick`（接口响应 → 设置新状态 → `$nextTick` → 关闭旧状态）
  - **典型代码模式**：
    ```js
    // 错误的测试用例
    await wrapper.vm.handleContinueBackFill();
    expect(wrapper.vm.validationVisible).toBe(false); // 失败：需要等待 $nextTick
    ```
  - **快速检查**：
    - 检查测试用例是否等待了所有异步操作完成
    - 检查是否使用了 `await nextTick()` 等待 DOM 更新
    - 检查是否需要等待多个 `$nextTick`（接口响应 → 设置新状态 → `$nextTick` → 关闭旧状态）
  - **修复建议**：
    - 等待所有异步操作完成（`await nextTick()`，可能需要多个 `$nextTick`）
    - 在接口响应后，等待设置新状态和 `$nextTick` 完成后再检查状态
    - 考虑使用 `setTimeout` 或 `flushPromises` 等待所有异步操作完成

### 4. 方法职责混淆问题

- **4.1 期望某个方法执行操作，但实际职责不同**
  - **风险类型**：测试用例调用错误的方法，期望执行某个操作，但该方法实际职责不同。
  - **典型现象**：
    - 测试用例调用 `handleCloseInternal`，期望关闭所有模态框
    - 但 `handleCloseInternal` 只负责关闭主模态框，不负责关闭校验模态框和更新模态框
    - 测试用例失败，期望的行为与实际方法职责不一致
  - **关键成因**：
    - 方法职责划分不清晰
    - 测试用例基于错误的假设编写
    - 没有理解方法的实际职责
  - **典型代码模式**：
    ```js
    // 错误的测试用例
    wrapper.vm.handleCloseInternal(); // 期望关闭所有模态框
    expect(wrapper.vm.validationVisible).toBe(false); // 失败：handleCloseInternal 不负责关闭校验模态框
    ```
  - **快速检查**：
    - 检查测试用例是否调用了正确的方法
    - 检查方法的实际职责是否与测试用例期望一致
    - 检查方法职责是否清晰（是否有注释说明）
  - **修复建议**：
    - 明确方法职责，在代码注释中说明方法的职责
    - 测试用例应该调用正确的方法（如 `handleClose` 而不是 `handleCloseInternal`）
    - 确保方法只负责自己的职责范围

- **4.2 方法职责划分不清晰**
  - **风险类型**：方法职责划分不清晰，导致测试用例和代码逻辑混乱。
  - **典型现象**：
    - 多个方法都执行相同的操作，职责重叠
    - 测试用例不知道应该调用哪个方法
    - 代码维护困难，修改一个方法可能影响其他方法
  - **关键成因**：
    - 方法职责没有明确划分
    - 没有在代码注释中说明方法的职责
    - 方法之间职责重叠
  - **快速检查**：
    - 检查方法职责是否清晰（是否有注释说明）
    - 检查方法之间是否有职责重叠
    - 检查测试用例是否知道应该调用哪个方法
  - **修复建议**：
    - 明确方法职责，在代码注释中说明方法的职责
    - 确保方法只负责自己的职责范围
    - 避免方法之间职责重叠

## 相关文件

- 排查清单：`.cursor/skills/todolist/数据流问题排查清单.md`
- Skill 文档：`.cursor/skills/data-flow-check.md`
- 组件实现示例：`src/components/Button/fileManage/backFill/modal_v1.5.vue`
- 测试示例：`tests/unit/components/BackFillModal_v1.5.test.js`
