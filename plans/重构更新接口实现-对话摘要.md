# 重构更新接口实现 - 对话摘要

## 任务目标

重构更新词条功能，实现基于任务状态的异步更新流程：
- 将原来的"更新"按钮改名为"更新v1"（旧流程）
- 新增"更新"按钮实现新流程（v2版本）
- 复用现有 `updateModal.vue` 组件
- 使用版本号控制流程（null/v1=旧流程，v2=新流程）

## API接口

### 1. 创建更新任务
- **接口**: `/entryInfo/getEntrysourceListByClassfy`
- **方法**: POST
- **参数**: `{ classifyID, i18nUrl }`
- **响应**: `{ code: 200, message: "创建词条更新任务成功" }`

### 2. 查询任务状态
- **接口**: `/backendInfo/getEntrysourceListByClassfyTaskState`
- **方法**: POST
- **参数**: `{ classfyID, i18nUrl }`
- **响应**: `{ data: { state: "0"|"1"|"2"|"3"|"4"|"5"|"6" } }`

**状态值说明**:
- 0: 没有查到正在执行的任务信息
- 1: 任务执行成功
- 2: 任务正在执行中
- 3: 任务执行失败
- 4: 任务终止执行
- 5: 任务终止执行失败
- 6: 系统服务存在异常

### 3. 获取任务结果
- **接口**: `/backendInfo/getEntrysourceListByClassfyResult`
- **方法**: POST
- **参数**: `{ classfyID, i18nUrl }`
- **响应**: 与原先的更新词条接口响应相同

## 数据流

### localStorage缓存逻辑
- **无缓存**: 首次打开右键菜单 → 直接打开更新弹窗 → 用户选择i18nUrl → 保存到localStorage
- **有缓存**: 读取localStorage中的i18nUrl → 执行状态查询 → 根据状态决定是否打开弹窗

### 状态处理流程
- **状态0**: 打开弹窗 → 用户选择IP和词条 → 点击确定创建任务 → 启动轮询 → 状态变为1后，用户再次点击确定 → 写库
- **状态1**: 打开弹窗 → 用户选择IP（优先使用缓存） → 点击确定 → 获取结果 → 写库
- **状态2**: 灰禁按钮，显示"执行更新中"和loading，不打开弹窗
- **状态3/4/5/6**: 使用notification.error通知用户任务执行失败

## 关键实现

### 1. 版本控制
- `updateModal.vue` 使用 `version` prop: `null`/`'v1'`=旧流程，`'v2'`=新流程
- `taskStatus` prop: 传递任务状态（0/1/2/3/4/5/6）
- 直接判断 `this.version === 'v2'`，不使用冗余的 `isNewUpdateFlow` 属性

### 2. 多请求轮询机制
- **文件**: `src/utils/pollingUtils.js`
- **函数**: `createMultiRequestPolling(options)`
- **功能**: 
  - 管理多个请求的轮询列表
  - 所有请求共享同一个定时器，统一按周期执行
  - 新请求加入时，如果轮询已运行，等待到下一个周期执行
  - 支持 `initialRequests` 参数传入初始请求列表
- **方法**: `addRequest(checkFn, onStatusChange)`, `removeRequest(requestId)`, `start()`, `stop()`

### 3. localStorage缓存
- **key**: `commonParam.updateEntry.localStorageKey` (值为 `"updateEntryI18nUrl"`)
- **存储时机**: 用户选择i18nUrl后保存
- **读取时机**: 打开弹窗时优先使用缓存的i18nUrl

### 4. 常量管理
- **文件**: `src/constants/commonParam.js`
- **添加**: `updateEntry.localStorageKey` 和 `updateEntry.pollingInterval`
- **注意**: 前后端约定的固定值（如状态值0-6）不放到constants中

## 文件修改清单

### 新增文件
- `src/utils/pollingUtils.js` - 多请求轮询管理器
- `tests/unit/http/api/backendInfo.test.js` - backendInfo API单元测试

### 修改文件
- `src/constants/commonParam.js` - 添加更新相关常量
- `src/http/api/entryManage.js` - 添加 `createEntrysourceListByClassfyTask`
- `src/http/api/backendInfo.js` - 添加 `getEntrysourceListByClassfyTaskState` 和 `getEntrysourceListByClassfyResult`
- `src/views/entry/index.vue` - 修改右键菜单，添加v2更新入口，实现localStorage缓存逻辑
- `src/views/entry/updateModal.vue` - 添加v2流程支持，实现多请求轮询
- `tests/unit/http/api/entryManage.test.js` - 添加新接口的单元测试

## 关键代码位置

### index.vue
- 第23行: "更新v1"按钮
- 第24行: "更新"按钮（v2），带disabled和loading控制
- 第81行: UpdateModal组件，传递version和taskStatus
- 第164-166行: updateV2相关数据属性
- 第333-339行: update()方法（v1）
- 第340-366行: updateV2()方法（v2入口）
- 第376-399行: handleUpdateV2Status()方法（状态处理）

### updateModal.vue
- 第62-65行: version和taskStatus props定义
- 第127行: pollingRequestIds Map存储请求ID
- 第133-149行: watch visible，处理localStorage缓存
- 第243-270行: handleOK()方法，根据version和状态处理
- 第375-448行: startTaskPolling()方法，使用多请求轮询

### pollingUtils.js
- 第100-247行: createMultiRequestPolling函数实现
- 第108行: requests Map存储请求列表
- 第164-180行: addRequest方法
- 第186-192行: removeRequest方法

## 注意事项

1. 所有新接口均为POST方法
2. 写库操作需用户手动点击确定按钮触发，不是自动
3. 状态2时显示loading，按钮文字改为"执行更新中"
4. 状态3/4/5/6时使用notification.error通知用户，不是调用旧流程
5. 多请求轮询：新请求加入时，如果轮询已运行，等待到下一个周期执行（不立即执行）
6. 每个任务使用 `classfyID_i18nUrl` 作为唯一标识，避免重复添加
